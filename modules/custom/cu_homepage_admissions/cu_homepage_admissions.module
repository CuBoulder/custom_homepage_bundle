<?php
/**
 * @file
 * Code for the CU Homepage Admissions feature.
 */

include_once 'cu_homepage_admissions.features.inc';

/**
 * Implements hook_page_alter().
 *
 * @param $page
 */
function cu_homepage_admissions_page_alter(&$page) {
  if (request_path() == 'admissions/connect/events') {

    // Add baseURL to Drupal JS object to retrieve later.
    global $base_url;
    drupal_add_js(array('baseUrl' => $base_url), 'setting');

    drupal_add_js(drupal_get_path('module', 'cu_homepage_admissions') . '/js/reset_content.js');
    drupal_add_css(drupal_get_path('module', 'cu_homepage_admissions') . '/css/admissions_events.css');
  }
}

/**
 * Implements hook_menu().
 *
 * @return array
 *   An array of menu items.
 */
function cu_homepage_admissions_menu() {
  $items = array();
  $items['admissions/connect/events/ajax'] = array(
    'title' => 'AJAX Response for Admissions Events',
    'page callback' => 'cu_homepage_admissions_ajax',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/content/admissions'] = array(
    'title' => 'Admissions Section Configuration',
    'description' => 'Configuration for the admissions section of the homepage.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cu_homepage_admissions_config_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/content/admissions/import'] = array(
    'title' => 'Admissions Counselor Import',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -20,
  );

  return $items;
}

/**
 * Callback for admin/config/content/admissions.
 *
 * @return array
 */
function cu_homepage_admissions_config_form($form_state) {
  $form = array();

  $form['file'] = array(
    '#type' => 'managed_file',
    '#title' => t('Image'),
    '#description' => t('Upload a .csv to convert for Feeds importer.'),
    '#upload_location' => 'public://feeds',
    "#upload_validators"  => array('file_validate_extensions' => array('csv')),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Process'),
  );

  return $form;
}

/**
 * Submit callback for cu_homepage_admissions_config_form.
 *
 * @param $form
 * @param $form_state
 */
function cu_homepage_admissions_config_form_submit($form, &$form_state) {

  // Load file contents.
  $file = file_load($form_state['values']['file']);
  $filepath = drupal_realpath($file->uri);
  $file_contents = str_getcsv(file_get_contents($filepath));

  // @todo make the following two variables into something you can change in the UI.

  // Currently 9 headers.
  $headers = array(
    0 => 'person_nid',
    1 => 'lastname',
    2 => 'location1',
    3 => 'location2',
    4 => 'location3',
    5 => 'location4',
    6 => 'location5',
    7 => 'location6',
    8 => 'comments',
  );

  // Six locations.
  $locations =  array(
    2 => 'location1',
    3 => 'location2',
    4 => 'location3',
    5 => 'location4',
    6 => 'location5',
    7 => 'location6',
  );

  $locations_array = array();
  $i = 0;
  $j = 0;
  foreach ($file_contents as $key => $item) {
    $locations_array[$i][$headers[$j]] = $item;
    $j++;

    if ($key % 8 == 0 && $key != 0) {
      $j = 0;
      $i++;
    }
  }

  // First key is useless. Jank it up!
  $header_row = array_shift($locations_array);

  $counselors = array();
  foreach ($locations_array as $key => $item) {
    // Check and see if last item has the same name.
    if ($item['lastname'] == $locations_array[$key - 1]['lastname'] || $item['lastname'] = $locations_array[$key + 1]['lastname']) {
      // Then add locations to person if not exist.
      foreach ($locations as $location_key => $location) {
        if (!in_array($item[$location], $counselors[$item['lastname']]) && !empty($item[$location])) {
          // Replace commas.
          $item[$location] = str_replace(',', '-', $item[$location]);

          // Add locations to related counselors.
          $counselors[$item['lastname']][] = $item[$location];
        }
      }
    }

  }

  // Make header row.
  $counselor_file = "lastname,all_terms,\r\n";

  // Add terms to output file.
  foreach ($counselors as $counselor => $terms) {
    $counselor_file .= $counselor . ',' . implode('|', $terms) . ",\r\n";
  }

  // Output and download file.
  file_put_contents(drupal_realpath('public://feeds/') . '/counselors.csv', $counselor_file);
  $form_state['redirect'] = 'sites/default/files/feeds/counselors.csv';
}

/**
 * Page callback to return rendered view via AJAX.
 */
function cu_homepage_admissions_ajax() {
  $views = array();
  $views['main_events'] = views_embed_view('admission_events_and_counselors_geolocation_view', 'block');
  $views['featured_events'] = views_embed_view('admission_events_and_counselors_geolocation_view', 'block_1');
  print json_encode($views);
}

/**
 * Implements hook_views_query_alter().
 *
 * Add location data to views query if the data is present.
 *
 * @param $view
 * @param $query
 */
function cu_homepage_admissions_views_query_alter(&$view, &$query) {
  // Pass in location data to views filter.
  if ($view->name == 'admission_events_and_counselors_geolocation_view') {
    $query_params = drupal_get_query_parameters();
    if (array_key_exists('lat', $query_params)) {
      $view->query->where[1]['conditions'][3]['field'] = '( 3959 * ACOS( COS( RADIANS(' . $query_params['lat'] . ') ) * COS( RADIANS(field_data_field_adm_event_geofield.field_adm_event_geofield_lat) ) * COS( RADIANS(field_data_field_adm_event_geofield.field_adm_event_geofield_lon) - RADIANS(' . $query_params['long'] . ') ) + SIN( RADIANS(' . $query_params['lat'] . ') ) * SIN( RADIANS(field_data_field_adm_event_geofield.field_adm_event_geofield_lat) ) ) ) <= 50';
    }
  }
}

/**
 * Implements hook_form_views_exposed_form_alter().
 *
 * Take address data and geocode it for views output.
 *
 * @param $form
 * @param $form_state
 */
function cu_homepage_admissions_form_views_exposed_form_alter(&$form, &$form_state) {
  // Need to limit this to only this view.
  if (request_path() == 'admissions/connect/events') {
    // Add submit function before regular views submit so coordinates can be passed.
    //if (!in_array('cu_homepage_admissions_address_submit', $form['#submit'])) {
      array_unshift($form['#submit'], 'cu_homepage_admissions_address_submit');
    //}
  }
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function cu_homepage_admissions_ctools_plugin_directory($owner, $plugin_type){
  if ($owner == 'feeds_tamper' && $plugin_type == 'plugins') {
    return 'plugins';
  }
}

/**
 * Convert Address from exposed filter to geo coordinates.
 *
 * @param $form
 * @param $form_state
 */
function cu_homepage_admissions_address_submit(&$form, &$form_state) {

  // Get coordinates.
  $geo_data = cu_homepage_admissions_geocoder_google($form_state['values']['field_person_address_value']);

  // If no result, e.g no object returned, then...return.
  if (!is_object($geo_data)) {
    return;
  }

  // Reset address field to not conflict with geo coordinates.
  $form_state['values']['field_person_address_value'] = NULL;

  // Pass back coordinates into views query.
  $form_state['values']['field_geofield_distance']['origin']['lat'] = $geo_data->coords[1];
  $form_state['values']['field_geofield_distance']['origin']['lon'] = $geo_data->coords[0];

  // Use hidden form element.
  $form['position'] = array(
    '#type' => 'hidden',
    '#value' => $geo_data->coords[1] . ',' . $geo_data->coords[0],
    '#attributes' => array(
      'class' => array('hidden-position-data'),
    ),
  );

}

/**
 * Using function from Geocoder module to convert addressfield to coordinates.
 *
 * Located in geocode/plugins/geocoder_handler/google.inc.
 */
function cu_homepage_admissions_geocoder_google($address, $options = array()) {

  // Don't do anything if there is no address.
  if (empty($address)) {
    return;
  }

  try {
    geophp_load();

    $query = array(
      'address' => $address,
      'sensor' => 'false',
    );

    $url = url("http://maps.googleapis.com/maps/api/geocode/json", array('query' => $query));
    $result = drupal_http_request($url);

    if (isset($result->error)) {
      $args = array(
        '@code' => $result->code,
        '@error' => $result->error,
      );
      $msg = t('HTTP request to google API failed.\nCode: @code\nError: @error', $args);
      throw new Exception($msg);
    }

    $data = json_decode($result->data);

    if ($data->status != 'OK') {
      $args = array('@status' => $data->status);
      $msg = t('Google API returned bad status.\nStatus: @status', $args);
      throw new Exception($msg);
    }

    $geometries = array();

    foreach ($data->results as $item) {
      // Check if we should reject these results
      if (isset($options['reject_results'])) {
        if (in_array($item->geometry->location_type, $options['reject_results'], TRUE)) {
          continue;
        }
      }

      // Construct a geoPHP Geometry depending on what type of geometry we want returned (defaults to point)
      if (!isset($options['geometry_type']) || $options['geometry_type'] == 'point') {
        $geom = new Point($item->geometry->location->lng, $item->geometry->location->lat);
      }
      elseif ($options['geometry_type'] == 'bounds') {
        $points = array(
          new Point($item->geometry->bounds->southwest->lng, $item->geometry->bounds->southwest->lat),
          new Point($item->geometry->bounds->southwest->lng, $item->geometry->bounds->northeast->lat),
          new Point($item->geometry->bounds->northeast->lng, $item->geometry->bounds->northeast->lat),
          new Point($item->geometry->bounds->northeast->lng, $item->geometry->bounds->southwest->lat),
          new Point($item->geometry->bounds->southwest->lng, $item->geometry->bounds->southwest->lat),
        );
        $geom = new Polygon(array(new LineString($points)));
      }
      elseif ($options['geometry_type'] == 'viewport') {
        $points = array(
          new Point($item->geometry->viewport->southwest->lng, $item->geometry->viewport->southwest->lat),
          new Point($item->geometry->viewport->southwest->lng, $item->geometry->viewport->northeast->lat),
          new Point($item->geometry->viewport->northeast->lng, $item->geometry->viewport->northeast->lat),
          new Point($item->geometry->viewport->northeast->lng, $item->geometry->viewport->southwest->lat),
          new Point($item->geometry->viewport->southwest->lng, $item->geometry->viewport->southwest->lat),
        );
        $geom = new Polygon(array(new LineString($points)));
      }

      // Add additional metadata to the geometry - it might be useful!
      $geom->data = array();
      $geom->data['geocoder_accuracy'] = $item->geometry->location_type;
      $geom->data['geocoder_formatted_address'] = $item->formatted_address;
      $geom->data['geocoder_address_components'] = $item->address_components;

      $geometries[] = $geom;
    }

    if (empty($geometries)) {
      return;
    }

    // Check if we should return all results as a compound geometry
    if (isset($options['all_results'])) {
      if ($options['all_results']) {
        return geoPHP::geometryReduce($geometries);
      }
    }
    // The connonical geometry is the first result (best guesse)
    $geometry = array_shift($geometries);

    // If there are any other geometries, these are auxiliary geometries that represent "alternatives"
    if (count($geometries)) {
      $geometry->data['geocoder_alternatives'] = $geometries;
    }

    return $geometry;
  } catch (Exception $e) {
    watchdog_exception('geocoder', $e);
    return FALSE;
  }
}
